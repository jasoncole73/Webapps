<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
    /* Styles specific to Chess game */
    body { margin: 0; height: 100vh; background-color: #f0d9b5; font-family: Tahoma, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; overflow: hidden;}
    .game-controls { padding: 5px; background-color: #e0e0e0; text-align: center; width: 100%; border-bottom: 1px solid #ccc; flex-shrink: 0; }
    .game-controls button { font-size: 12px; padding: 3px 10px; margin: 0 5px;}
    .game-status { font-size: 13px; font-weight: bold; padding: 3px 0;}
    #chessboard { display: grid; grid-template-columns: repeat(8, 50px); grid-template-rows: repeat(8, 50px); width: 400px; height: 400px; border: 2px solid #333; margin: 10px auto; /* Centered with margin */ }
    .chess-square { width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; font-size: 38px; cursor: pointer; }
    .chess-square.light { background-color: #f0d9b5; } .chess-square.dark { background-color: #b58863; }
    .chess-square.selected-piece { background-color: #7efc00 !important; } .chess-square.possible-move { background-color: #add8e6 !important; }
    .chess-square.possible-capture::after { content: ''; width: 10px; height: 10px; background-color: red; border-radius: 50%; position: absolute; margin-left: 25px; margin-top: -25px; /* Adjust indicator */ }
    .chess-piece-white { color: #ffffff; text-shadow: 0 0 2px black, 0 0 2px black; } .chess-piece-black { color: #333333; }
    .king-in-check { background-color: #ff7f7f !important; }
</style>
</head>
<body>
    <div id="chess-controls" class="game-controls">
        <button id="chess-new-game">New Game</button>
        <span id="chess-status" class="game-status">White to move</span>
    </div>
    <div id="chessboard">
        <!-- Squares generated by JS -->
    </div>
    <script>
        // --- Chess JS Logic (copied from previous) ---
        const chessboardDiv = document.getElementById('chessboard'); const chessStatusDiv = document.getElementById('chess-status');
        const CHESS_PIECES = { 'P': { type: 'pawn', unicode: '♙'}, 'R': { type: 'rook', unicode: '♖'}, 'N': { type: 'knight', unicode: '♘'}, 'B': { type: 'bishop', unicode: '♗'}, 'Q': { type: 'queen', unicode: '♕'}, 'K': { type: 'king', unicode: '♔'}, 'p': { type: 'pawn', unicode: '♟'}, 'r': { type: 'rook', unicode: '♜'}, 'n': { type: 'knight', unicode: '♞'}, 'b': { type: 'bishop', unicode: '♝'}, 'q': { type: 'queen', unicode: '♛'}, 'k': { type: 'king', unicode: '♚'} };
        let chessBoard = [], currentChessPlayer = 'white', selectedChessPiece = null, chessGameOver = false, whiteKingPos = {r:7,c:4}, blackKingPos = {r:0,c:4};
        let aiMoveTimeout = null; // To store the timeout ID

        function setupInitialChessBoard() { chessBoard = [ ['r','n','b','q','k','b','n','r'], ['p','p','p','p','p','p','p','p'], [null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null], ['P','P','P','P','P','P','P','P'], ['R','N','B','Q','K','B','N','R'] ]; whiteKingPos = {r:7,c:4}; blackKingPos = {r:0,c:4}; currentChessPlayer = 'white'; selectedChessPiece = null; chessGameOver = false; if (aiMoveTimeout) clearTimeout(aiMoveTimeout); aiMoveTimeout = null; updateChessStatus("White to move"); renderChessboard(); }
        function renderChessboard() { chessboardDiv.innerHTML = ''; let wk_check = isKingInCheck('white'), bk_check = isKingInCheck('black'); for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) { const sq = document.createElement('div'); sq.classList.add('chess-square', (r + c) % 2 === 0 ? 'light' : 'dark'); sq.dataset.row = r; sq.dataset.col = c; const pc = chessBoard[r][c]; if (pc) { const p = CHESS_PIECES[pc]; sq.textContent = p.unicode; sq.classList.add(pc === pc.toUpperCase() ? 'chess-piece-white' : 'chess-piece-black'); if(p.type==='king'){if(pc==='K'&&wk_check)sq.classList.add('king-in-check'); if(pc==='k'&&bk_check)sq.classList.add('king-in-check');}} sq.addEventListener('click', handleChessSquareClick); chessboardDiv.appendChild(sq); } }
        function handleChessSquareClick(event) { if (chessGameOver || currentChessPlayer === 'black') return; const r = parseInt(event.currentTarget.dataset.row), c = parseInt(event.currentTarget.dataset.col), pc = chessBoard[r][c]; if (selectedChessPiece) { const vm = getValidChessMoves(selectedChessPiece.p, selectedChessPiece.r, selectedChessPiece.c); const ivm = vm.some(m => m.r === r && m.c === c); if (ivm) { makeChessMove(selectedChessPiece.r, selectedChessPiece.c, r, c); selectedChessPiece = null; clearChessHighlights(); if (!chessGameOver) { switchChessPlayer(); if (currentChessPlayer === 'black' && !chessGameOver) { if (aiMoveTimeout) clearTimeout(aiMoveTimeout); aiMoveTimeout = setTimeout(makeChessAIMove, 500); } } } else if (pc && isOwnChessPiece(pc, currentChessPlayer)) { selectedChessPiece = { p: pc, r, c }; highlightPossibleChessMoves(); } else { selectedChessPiece = null; clearChessHighlights(); } } else if (pc && isOwnChessPiece(pc, currentChessPlayer)) { selectedChessPiece = { p: pc, r, c }; highlightPossibleChessMoves(); } }
        function isOwnChessPiece(pc, pl) { if (!pc) return false; return (pl === 'white' && pc === pc.toUpperCase()) || (pl === 'black' && pc === pc.toLowerCase()); }
        function highlightPossibleChessMoves() { clearChessHighlights(); if (!selectedChessPiece) return; const ps = chessboardDiv.querySelector(`.chess-square[data-row='${selectedChessPiece.r}'][data-col='${selectedChessPiece.c}']`); if(ps) ps.classList.add('selected-piece'); const vm = getValidChessMoves(selectedChessPiece.p, selectedChessPiece.r, selectedChessPiece.c); vm.forEach(m => { const ms = chessboardDiv.querySelector(`.chess-square[data-row='${m.r}'][data-col='${m.c}']`); if (ms) { ms.classList.add('possible-move'); if (chessBoard[m.r][m.c]) ms.classList.add('possible-capture'); } }); }
        function clearChessHighlights() { document.querySelectorAll('.chess-square.selected-piece, .chess-square.possible-move, .chess-square.possible-capture').forEach(sq => sq.classList.remove('selected-piece', 'possible-move', 'possible-capture')); }
        function getValidChessMoves(pc, r, c, csc = true) { const pt = CHESS_PIECES[pc].type, co = (pc === pc.toUpperCase()) ? 'white' : 'black'; let mvs = []; const addM = (dr, dc, cont = false) => { let nr = r + dr, nc = c + dc; while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) { const tpc = chessBoard[nr]?.[nc]; if (tpc === null) mvs.push({ r: nr, c: nc }); else { if (!isOwnChessPiece(tpc, co)) mvs.push({ r: nr, c: nc }); break; } if (!cont) break; nr += dr; nc += dc; } }; if (pt === 'pawn') { const dir = co === 'white' ? -1 : 1; if (r+dir>=0 && r+dir<8 && chessBoard[r+dir][c] === null) mvs.push({ r: r+dir, c }); if (((co==='white'&&r===6)||(co==='black'&&r===1)) && chessBoard[r+dir]?.[c]===null && chessBoard[r+2*dir]?.[c]===null) mvs.push({ r:r+2*dir, c }); [-1,1].forEach(cd => { if (c+cd>=0 && c+cd<8 && r+dir>=0 && r+dir<8 && chessBoard[r+dir][c+cd] && !isOwnChessPiece(chessBoard[r+dir][c+cd],co)) mvs.push({r:r+dir,c:c+cd}); }); } else if (pt === 'rook') [[0,1],[0,-1],[1,0],[-1,0]].forEach(d=>addM(d[0],d[1],true)); else if (pt === 'knight') [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]].forEach(d=>addM(d[0],d[1])); else if (pt === 'bishop') [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d=>addM(d[0],d[1],true)); else if (pt === 'queen' || pt === 'king') [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(d=>addM(d[0],d[1],pt==='queen')); if (csc) mvs = mvs.filter(mv => { const tb = JSON.parse(JSON.stringify(chessBoard)); const op = tb[r][c]; tb[mv.r][mv.c]=op; tb[r][c]=null; let kp = (co==='white')?whiteKingPos:blackKingPos; if(CHESS_PIECES[pc].type==='king')kp={r:mv.r,c:mv.c}; return !isPositionUnderAttack(kp.r, kp.c, (co==='white'?'black':'white'), tb); }); return mvs; }
        function makeChessMove(r1,c1,r2,c2) { const pc=chessBoard[r1][c1], cap_pc=chessBoard[r2][c2]; chessBoard[r2][c2]=pc; chessBoard[r1][c1]=null; if(CHESS_PIECES[pc].type==='king'){if(currentChessPlayer==='white')whiteKingPos={r:r2,c:c2};else blackKingPos={r:r2,c:c2};} renderChessboard(); if(cap_pc&&CHESS_PIECES[cap_pc].type==='king'){chessGameOver=true; if(aiMoveTimeout) clearTimeout(aiMoveTimeout); updateChessStatus(`${currentChessPlayer==='white'?'White':'Black'} wins by King capture!`); return;} const oppC = currentChessPlayer==='white'?'black':'white'; if(isKingInCheck(oppC)){const allOppMvs = getAllValidChessMovesForPlayer(oppC); if(allOppMvs.length===0){chessGameOver=true; if(aiMoveTimeout) clearTimeout(aiMoveTimeout); updateChessStatus(`Checkmate! ${currentChessPlayer.charAt(0).toUpperCase()+currentChessPlayer.slice(1)} wins!`);} else updateChessStatus(`${oppC.charAt(0).toUpperCase()+oppC.slice(1)} in Check! ${currentChessPlayer==='white'?'Black':'White'} to move.`);} else { const allOppMvs = getAllValidChessMovesForPlayer(oppC); if(allOppMvs.length===0){chessGameOver=true; if(aiMoveTimeout) clearTimeout(aiMoveTimeout); updateChessStatus(`Stalemate! It's a draw.`);} else updateChessStatus(`${currentChessPlayer==='white'?'Black':'White'} to move`);} }
        function isPositionUnderAttack(r,c,attC,brd=chessBoard){for(let i=0;i<8;i++)for(let j=0;j<8;j++){const pc=brd[i][j]; if(pc&&isOwnChessPiece(pc,attC)){const mvs=getValidChessMoves(pc,i,j,false); if(mvs.some(m=>m.r===r&&m.c===c))return true;}} return false;}
        function isKingInCheck(kC,brd=chessBoard){const kp=kC==='white'?whiteKingPos:blackKingPos; if(!kp) return false; const attC=kC==='white'?'black':'white'; return isPositionUnderAttack(kp.r,kp.c,attC,brd);}
        function getAllValidChessMovesForPlayer(plC){let allMvs=[]; for(let r=0;r<8;r++)for(let c=0;c<8;c++){const pc=chessBoard[r][c]; if(pc&&isOwnChessPiece(pc,plC)){const mvs=getValidChessMoves(pc,r,c); mvs.forEach(m=>allMvs.push({from:{r,c},to:{r:m.r,c:m.c},p:pc}));}} return allMvs;} // Ensure 'to' structure matches move obj
        function makeChessAIMove() { if (chessGameOver||currentChessPlayer!=='black') return; const allMvs=getAllValidChessMovesForPlayer('black'); if(allMvs.length===0){chessGameOver=true;if(isKingInCheck('black'))updateChessStatus("Checkmate! White wins!"); else updateChessStatus("Stalemate! Draw."); renderChessboard(); return;} const ranMv=allMvs[Math.floor(Math.random()*allMvs.length)]; makeChessMove(ranMv.from.r,ranMv.from.c,ranMv.to.r,ranMv.to.c); if(!chessGameOver) switchChessPlayer(); }
        function switchChessPlayer() { currentChessPlayer = (currentChessPlayer==='white')?'black':'white'; updateStatusAndCheckEndgame(); }
        function updateStatusAndCheckEndgame() { if(!chessGameOver){ const isCheck = isKingInCheck(currentChessPlayer); const allMoves = getAllValidChessMovesForPlayer(currentChessPlayer); if (allMoves.length === 0) { chessGameOver = true; if (isCheck) updateChessStatus(`Checkmate! ${currentChessPlayer === 'white' ? 'Black' : 'White'} wins!`); else updateChessStatus("Stalemate! It's a draw."); if(aiMoveTimeout) clearTimeout(aiMoveTimeout); } else if (isCheck) { updateChessStatus(`${currentChessPlayer.charAt(0).toUpperCase() + currentChessPlayer.slice(1)} is in Check! Your move.`); } else { updateChessStatus(`${currentChessPlayer.charAt(0).toUpperCase() + currentChessPlayer.slice(1)} to move`); } } renderChessboard(); }
        function updateChessStatus(msg){chessStatusDiv.textContent=msg;}

        // --- Setup ---
        document.getElementById('chess-new-game').addEventListener('click', setupInitialChessBoard);
        setupInitialChessBoard(); // Start game on load

        // --- Cleanup Function ---
        function cleanupGame() {
            console.log("Cleaning up Chess");
            if (aiMoveTimeout) {
                clearTimeout(aiMoveTimeout);
                aiMoveTimeout = null;
            }
        }
    </script>
</body>
</html>