<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Connect Four</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f0f0f0; 
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            color: #333;
        }
        #game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 560px; 
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: bold;
        }
        #currentPlayerTurn {
            padding: 5px 10px;
            border-radius: 5px;
            color: white;
        }
        .player1-turn { background-color: #FF4136; /* Red */ }
        .player2-turn { background-color: #FFDC00; /* Yellow */ }
        .ai-thinking { background-color: #777; } /* Grey for AI thinking */

        #gameCanvas {
            background-color: #0074D9; 
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            cursor: pointer;
        }
        #message-area {
            margin-top: 20px;
            font-size: 1.5em;
            font-weight: bold;
            color: #0074D9;
            min-height: 30px;
        }
        #restartButton {
            margin-top: 10px;
            padding: 10px 25px;
            font-size: 1em;
            font-weight: bold;
            color: white;
            background-color: #2ECC40; 
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            display: none; 
        }
        #restartButton:hover {
            background-color: #27ae60;
        }
    </style>
</head>
<body>
    <div id="game-info">
        <span id="currentPlayerTurn"></span>
        <div>Score: <span id="player1Score">0</span> (Red) - <span id="player2Score">0</span> (Yellow)</div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="message-area"></div>
    <button id="restartButton">Play Again</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const currentPlayerTurnDisplay = document.getElementById('currentPlayerTurn');
        const player1ScoreDisplay = document.getElementById('player1Score');
        const player2ScoreDisplay = document.getElementById('player2Score');
        const messageArea = document.getElementById('message-area');
        const restartButton = document.getElementById('restartButton');

        const ROWS = 6;
        const COLS = 7;
        const SQUARE_SIZE = 80; 
        const PIECE_RADIUS = SQUARE_SIZE / 2 - 8; 
        const BOARD_COLOR = '#0074D9';
        const EMPTY_SLOT_COLOR = '#0056a3'; 
        const PLAYER1_COLOR = '#FF4136'; // Human
        const PLAYER2_COLOR = '#FFDC00'; // AI
        const WINNING_PIECE_HIGHLIGHT = '#39CCCC'; 

        canvas.width = COLS * SQUARE_SIZE;
        canvas.height = ROWS * SQUARE_SIZE;

        let board = [];
        let currentPlayer = 1; 
        let gameOver = false;
        let player1Score = 0;
        let player2Score = 0;
        let droppingPiece = null; 
        let animationFrameId = null; 
        const AI_PLAYER_NUMBER = 2; // AI is Player 2
        const AI_THINKING_TIME = 700; // milliseconds

        function initializeBoard() {
            board = [];
            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = 0; 
                }
            }
        }

        function drawBoard() {
            ctx.fillStyle = BOARD_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    ctx.beginPath();
                    ctx.arc(c * SQUARE_SIZE + SQUARE_SIZE / 2, 
                            r * SQUARE_SIZE + SQUARE_SIZE / 2, 
                            PIECE_RADIUS, 0, Math.PI * 2);
                    
                    if (board[r][c] === 1) {
                        ctx.fillStyle = PLAYER1_COLOR;
                    } else if (board[r][c] === 2) {
                        ctx.fillStyle = PLAYER2_COLOR;
                    } else {
                        ctx.fillStyle = EMPTY_SLOT_COLOR;
                    }
                    ctx.fill();
                    ctx.strokeStyle = '#004080'; 
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }
        
        function drawDroppingPiece() {
            if (droppingPiece) {
                ctx.beginPath();
                ctx.arc(droppingPiece.col * SQUARE_SIZE + SQUARE_SIZE / 2, 
                        droppingPiece.y, 
                        PIECE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = droppingPiece.player === 1 ? PLAYER1_COLOR : PLAYER2_COLOR;
                ctx.fill();
                ctx.strokeStyle = '#004080';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function updateDroppingPiece() {
            if (droppingPiece) {
                droppingPiece.y += droppingPiece.speed;
                droppingPiece.speed += 0.8; 

                const targetY = droppingPiece.targetRow * SQUARE_SIZE + SQUARE_SIZE / 2;
                if (droppingPiece.y >= targetY) {
                    droppingPiece.y = targetY; 
                    board[droppingPiece.targetRow][droppingPiece.col] = droppingPiece.player;
                    
                    const gameHasEnded = checkEndConditions(droppingPiece.targetRow, droppingPiece.col, droppingPiece.player);
                    droppingPiece = null; // Animation finished

                    if (!gameHasEnded && currentPlayer === AI_PLAYER_NUMBER) {
                        // It's AI's turn after the human piece (or previous AI piece) has landed
                        setTimeout(aiMakeMove, AI_THINKING_TIME);
                    }
                }
            }
        }

        function checkEndConditions(r, c, player) {
            if (checkWin(r, c, player)) {
                gameOver = true;
                messageArea.textContent = (player === AI_PLAYER_NUMBER ? "Computer" : `Player ${player}`) + " Wins!";
                if (player === 1) player1Score++; else player2Score++;
                updateScoreDisplay();
                restartButton.style.display = 'block';
                return true;
            } else if (isBoardFull()) {
                gameOver = true;
                messageArea.textContent = "It's a Draw!";
                restartButton.style.display = 'block';
                return true;
            }
            // Switch player if game not ended
            currentPlayer = (player === 1) ? 2 : 1;
            updateTurnDisplay();
            return false;
        }


        function dropPiece(col, playerNum) { // Added playerNum parameter
            if (gameOver || droppingPiece) return false; 

            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][col] === 0) {
                    // console.log(`Dropping piece for player ${playerNum} in col ${col}, targetRow ${r}`); 
                    droppingPiece = {
                        col: col,
                        targetRow: r,
                        player: playerNum, // Use passed playerNum
                        y: SQUARE_SIZE / 2 - PIECE_RADIUS - 10, 
                        speed: 1 
                    };
                    return true; 
                }
            }
            // console.log(`Column ${col} is full.`); 
            return false; 
        }

        function checkWin(r, c, player) {
            let count = 0;
            for (let i = Math.max(0, c - 3); i <= Math.min(COLS - 1, c + 3); i++) {
                if (board[r][i] === player) count++; else count = 0;
                if (count >= 4) return true;
            }
            count = 0;
            for (let i = Math.max(0, r - 3); i <= Math.min(ROWS - 1, r + 3); i++) {
                if (board[i][c] === player) count++; else count = 0;
                if (count >= 4) return true;
            }
            count = 0;
            for (let i = -3; i <= 3; i++) {
                const row = r + i; const col = c + i;
                if (row >= 0 && row < ROWS && col >= 0 && col < COLS && board[row][col] === player) count++; else count = 0;
                if (count >= 4) return true;
            }
            count = 0;
            for (let i = -3; i <= 3; i++) {
                const row = r + i; const col = c - i; 
                if (row >= 0 && row < ROWS && col >= 0 && col < COLS && board[row][col] === player) count++; else count = 0;
                if (count >= 4) return true;
            }
            return false;
        }
        
        // highlightWinningPieces can be called if desired, but it's simplified
        // function highlightWinningPieces(r_win, c_win, player_win) { ... }


        function isBoardFull() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] === 0) return false;
                }
            }
            return true;
        }

        function updateTurnDisplay() {
            if (gameOver) return;
            if (currentPlayer === AI_PLAYER_NUMBER) {
                currentPlayerTurnDisplay.textContent = `Computer is thinking...`;
                currentPlayerTurnDisplay.className = 'ai-thinking';
            } else {
                currentPlayerTurnDisplay.textContent = `Player ${currentPlayer}'s Turn`;
                currentPlayerTurnDisplay.className = currentPlayer === 1 ? 'player1-turn' : 'player2-turn';
            }
        }
        
        function updateScoreDisplay() {
            player1ScoreDisplay.textContent = player1Score;
            player2ScoreDisplay.textContent = player2Score;
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBoard(); 

            if (droppingPiece) {
                updateDroppingPiece(); // This will handle player switching after animation
                drawDroppingPiece(); 
            }
            
            if (gameOver && droppingPiece === null) {
                // Game over logic is handled in checkEndConditions
            }

            if (!gameOver || droppingPiece) { // Continue loop if not game over OR if a piece is still dropping
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                console.log("Game Over. Loop stopped."); 
            }
        }

        function startGame() {
            initializeBoard();
            currentPlayer = 1; // Human always starts
            gameOver = false;
            droppingPiece = null; 
            updateTurnDisplay();
            updateScoreDisplay(); 
            messageArea.textContent = '';
            restartButton.style.display = 'none';
            
            if (animationFrameId) { 
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop); 
        }

        // --- AI Logic ---
        function aiMakeMove() {
            if (gameOver || currentPlayer !== AI_PLAYER_NUMBER || droppingPiece) return;
            console.log("AI is making a move..."); // DEBUG

            let chosenColumn = -1;

            // 1. Check if AI can win
            for (let c = 0; c < COLS; c++) {
                const r = getLowestEmptyRow(c);
                if (r !== -1) {
                    board[r][c] = AI_PLAYER_NUMBER; // Temporarily place piece
                    if (checkWin(r, c, AI_PLAYER_NUMBER)) {
                        chosenColumn = c;
                        board[r][c] = 0; // Undo test
                        break;
                    }
                    board[r][c] = 0; // Undo test
                }
            }

            // 2. Check if Player 1 can win and block
            if (chosenColumn === -1) {
                for (let c = 0; c < COLS; c++) {
                    const r = getLowestEmptyRow(c);
                    if (r !== -1) {
                        board[r][c] = 1; // Temporarily place opponent's piece
                        if (checkWin(r, c, 1)) {
                            chosenColumn = c;
                            board[r][c] = 0; // Undo test
                            break;
                        }
                        board[r][c] = 0; // Undo test
                    }
                }
            }

            // 3. Prefer center columns if no immediate win/block
            if (chosenColumn === -1) {
                const centerCols = [3, 2, 4, 1, 5, 0, 6]; // Order of preference
                for (let c of centerCols) {
                    if (getLowestEmptyRow(c) !== -1) {
                        chosenColumn = c;
                        break;
                    }
                }
            }
            
            // 4. Fallback to random available column
            if (chosenColumn === -1) {
                let availableCols = [];
                for (let c = 0; c < COLS; c++) {
                    if (getLowestEmptyRow(c) !== -1) {
                        availableCols.push(c);
                    }
                }
                if (availableCols.length > 0) {
                    chosenColumn = availableCols[Math.floor(Math.random() * availableCols.length)];
                }
            }

            if (chosenColumn !== -1) {
                dropPiece(chosenColumn, AI_PLAYER_NUMBER);
            } else {
                // This should ideally not happen if board is not full
                console.log("AI could not find a valid move (board might be full or error).");
            }
        }

        function getLowestEmptyRow(col) {
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][col] === 0) {
                    return r;
                }
            }
            return -1; // Column is full
        }


        canvas.addEventListener('click', (event) => {
            if (gameOver || droppingPiece || currentPlayer !== 1) { // Only allow human player to click
                // console.log("Click ignored: gameOver, piece dropping, or not player 1's turn"); 
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const col = Math.floor(x / SQUARE_SIZE);

            if (col >= 0 && col < COLS) {
                // console.log("Canvas clicked by Player 1, column:", col); 
                if (getLowestEmptyRow(col) !== -1) { // Check if column is not full
                    dropPiece(col, 1); // Player 1 drops piece
                }
            }
        });
        
        // Mousemove for hover indicator (simplified, can be enhanced)
        let hoverCol = -1;
        canvas.addEventListener('mousemove', (event) => {
            if (gameOver || droppingPiece || currentPlayer !== 1) {
                if(hoverCol !== -1) { // Clear previous hover if it existed
                    hoverCol = -1;
                    // The gameLoop will redraw and clear it
                }
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const newHoverCol = Math.floor(x / SQUARE_SIZE);

            if (newHoverCol !== hoverCol) {
                hoverCol = newHoverCol;
                // The gameLoop will now use hoverCol to draw the indicator
            }
        });
         canvas.addEventListener('mouseleave', () => {
            hoverCol = -1; // Clear hover when mouse leaves
        });

        // Modified gameLoop to include hover indicator drawing
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBoard(); 

            if (droppingPiece) {
                updateDroppingPiece();
                drawDroppingPiece(); 
            } else if (!gameOver && currentPlayer === 1 && hoverCol >= 0 && hoverCol < COLS && board[0][hoverCol] === 0) {
                // Draw hover indicator for human player
                ctx.beginPath();
                ctx.arc(hoverCol * SQUARE_SIZE + SQUARE_SIZE / 2, 
                        SQUARE_SIZE / 2 - PIECE_RADIUS / 2 , // Position at the top
                        PIECE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = PLAYER1_COLOR;
                ctx.globalAlpha = 0.5; 
                ctx.fill();
                ctx.globalAlpha = 1.0; 
            }
            
            if (gameOver && droppingPiece === null) {
                // Final win highlight can be added here if needed, by re-checking win
            }

            if (!gameOver || droppingPiece) { 
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                // console.log("Game Over. Loop stopped."); 
            }
        }


        restartButton.addEventListener('click', startGame);
        
        window.cleanupGame = () => {
            console.log("Connect Four cleanup called.");
            gameOver = true; 
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        };

        // Initial setup
        startGame();

    </script>
</body>
</html>
