<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Connect Four</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f0f0f0; /* Light grey background */
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            color: #333;
        }
        #game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 560px; /* Canvas width */
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: bold;
        }
        #currentPlayerTurn {
            padding: 5px 10px;
            border-radius: 5px;
            color: white;
        }
        .player1-turn { background-color: #FF4136; /* Red */ }
        .player2-turn { background-color: #FFDC00; /* Yellow */ }

        #gameCanvas {
            background-color: #0074D9; /* Classic Connect 4 Blue */
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            cursor: pointer;
        }
        #message-area {
            margin-top: 20px;
            font-size: 1.5em;
            font-weight: bold;
            color: #0074D9;
            min-height: 30px;
        }
        #restartButton {
            margin-top: 10px;
            padding: 10px 25px;
            font-size: 1em;
            font-weight: bold;
            color: white;
            background-color: #2ECC40; /* Green */
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            display: none; /* Hidden initially */
        }
        #restartButton:hover {
            background-color: #27ae60;
        }
    </style>
</head>
<body>
    <div id="game-info">
        <span id="currentPlayerTurn"></span>
        <div>Score: <span id="player1Score">0</span> - <span id="player2Score">0</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="message-area"></div>
    <button id="restartButton">Play Again</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const currentPlayerTurnDisplay = document.getElementById('currentPlayerTurn');
        const player1ScoreDisplay = document.getElementById('player1Score');
        const player2ScoreDisplay = document.getElementById('player2Score');
        const messageArea = document.getElementById('message-area');
        const restartButton = document.getElementById('restartButton');

        const ROWS = 6;
        const COLS = 7;
        const SQUARE_SIZE = 80; 
        const PIECE_RADIUS = SQUARE_SIZE / 2 - 8; 
        const BOARD_COLOR = '#0074D9';
        const EMPTY_SLOT_COLOR = '#0056a3'; 
        const PLAYER1_COLOR = '#FF4136'; 
        const PLAYER2_COLOR = '#FFDC00'; 
        const WINNING_PIECE_HIGHLIGHT = '#39CCCC'; 

        canvas.width = COLS * SQUARE_SIZE;
        canvas.height = ROWS * SQUARE_SIZE;

        let board = [];
        let currentPlayer = 1; 
        let gameOver = false;
        let player1Score = 0;
        let player2Score = 0;
        let droppingPiece = null; 
        let animationFrameId = null; // Added to manage animation frame

        function initializeBoard() {
            board = [];
            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    board[r][c] = 0; 
                }
            }
        }

        function drawBoard() {
            ctx.fillStyle = BOARD_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    ctx.beginPath();
                    ctx.arc(c * SQUARE_SIZE + SQUARE_SIZE / 2, 
                            r * SQUARE_SIZE + SQUARE_SIZE / 2, 
                            PIECE_RADIUS, 0, Math.PI * 2);
                    
                    if (board[r][c] === 1) {
                        ctx.fillStyle = PLAYER1_COLOR;
                    } else if (board[r][c] === 2) {
                        ctx.fillStyle = PLAYER2_COLOR;
                    } else {
                        ctx.fillStyle = EMPTY_SLOT_COLOR;
                    }
                    ctx.fill();
                    ctx.strokeStyle = '#004080'; 
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }
        
        function drawDroppingPiece() {
            if (droppingPiece) {
                // console.log("drawDroppingPiece at y:", droppingPiece.y); // DEBUG
                ctx.beginPath();
                ctx.arc(droppingPiece.col * SQUARE_SIZE + SQUARE_SIZE / 2, 
                        droppingPiece.y, 
                        PIECE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = droppingPiece.player === 1 ? PLAYER1_COLOR : PLAYER2_COLOR;
                ctx.fill();
                ctx.strokeStyle = '#004080';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function updateDroppingPiece() {
            if (droppingPiece) {
                // console.log("updateDroppingPiece. Current y:", droppingPiece.y, "speed:", droppingPiece.speed, "targetY:", droppingPiece.targetRow * SQUARE_SIZE + SQUARE_SIZE / 2); // DEBUG
                droppingPiece.y += droppingPiece.speed;
                droppingPiece.speed += 0.8; // Adjusted gravity for potentially smoother feel

                const targetY = droppingPiece.targetRow * SQUARE_SIZE + SQUARE_SIZE / 2;
                if (droppingPiece.y >= targetY) {
                    // console.log("Target reached. Snapping piece. DroppingPiece will be null."); // DEBUG
                    droppingPiece.y = targetY; 
                    board[droppingPiece.targetRow][droppingPiece.col] = droppingPiece.player;
                    
                    if (checkWin(droppingPiece.targetRow, droppingPiece.col, droppingPiece.player)) {
                        gameOver = true;
                        messageArea.textContent = `Player ${droppingPiece.player} Wins!`;
                        // highlightWinningPieces(droppingPiece.targetRow, droppingPiece.col, droppingPiece.player); // Call this after board is drawn with final piece
                        if (droppingPiece.player === 1) player1Score++; else player2Score++;
                        updateScoreDisplay();
                        restartButton.style.display = 'block';
                    } else if (isBoardFull()) {
                        gameOver = true;
                        messageArea.textContent = "It's a Draw!";
                        restartButton.style.display = 'block';
                    } else {
                        currentPlayer = (droppingPiece.player === 1) ? 2 : 1;
                        updateTurnDisplay();
                    }
                    droppingPiece = null; 
                }
            }
        }


        function dropPiece(col) {
            if (gameOver || droppingPiece) return false; 

            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][col] === 0) {
                    console.log(`Dropping piece for player ${currentPlayer} in col ${col}, targetRow ${r}`); // DEBUG
                    droppingPiece = {
                        col: col,
                        targetRow: r,
                        player: currentPlayer,
                        y: SQUARE_SIZE / 2 - PIECE_RADIUS - 10, // Start slightly higher
                        speed: 1 // Initial speed
                    };
                    // Do not change currentPlayer here; it changes after animation
                    return true; 
                }
            }
            console.log(`Column ${col} is full.`); // DEBUG
            return false; 
        }

        function checkWin(r, c, player) {
            let count = 0;
            for (let i = Math.max(0, c - 3); i <= Math.min(COLS - 1, c + 3); i++) {
                if (board[r][i] === player) count++; else count = 0;
                if (count >= 4) return true;
            }
            count = 0;
            for (let i = Math.max(0, r - 3); i <= Math.min(ROWS - 1, r + 3); i++) {
                if (board[i][c] === player) count++; else count = 0;
                if (count >= 4) return true;
            }
            count = 0;
            for (let i = -3; i <= 3; i++) {
                const row = r + i; const col = c + i;
                if (row >= 0 && row < ROWS && col >= 0 && col < COLS && board[row][col] === player) count++; else count = 0;
                if (count >= 4) return true;
            }
            count = 0;
            for (let i = -3; i <= 3; i++) {
                const row = r + i; const col = c - i; 
                if (row >= 0 && row < ROWS && col >= 0 && col < COLS && board[row][col] === player) count++; else count = 0;
                if (count >= 4) return true;
            }
            return false;
        }
        
        function highlightWinningPieces(r_win, c_win, player_win) {
            // Simplified: just make the winning pieces slightly larger or add a glow
            // This function would need to identify all 4 winning pieces.
            // For now, we'll just make the last dropped piece pulse if it was a winning move.
            // This should be called after the final board draw in gameLoop if gameOver.
            // A more robust solution would store the winning pieces and draw them differently.
            // console.log("Highlighting attempt for piece at:", r_win, c_win); // DEBUG
             ctx.strokeStyle = WINNING_PIECE_HIGHLIGHT;
             ctx.lineWidth = 5; // Thicker highlight
             ctx.beginPath();
             ctx.arc(c_win * SQUARE_SIZE + SQUARE_SIZE / 2, 
                     r_win * SQUARE_SIZE + SQUARE_SIZE / 2, 
                     PIECE_RADIUS + 3, 0, Math.PI * 2); // Slightly larger arc
             ctx.stroke();
        }


        function isBoardFull() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c] === 0) return false;
                }
            }
            return true;
        }

        function updateTurnDisplay() {
            currentPlayerTurnDisplay.textContent = `Player ${currentPlayer}'s Turn`;
            currentPlayerTurnDisplay.className = currentPlayer === 1 ? 'player1-turn' : 'player2-turn';
        }
        
        function updateScoreDisplay() {
            player1ScoreDisplay.textContent = player1Score;
            player2ScoreDisplay.textContent = player2Score;
        }


        function gameLoop() {
            // console.log("gameLoop running. droppingPiece:", droppingPiece, "gameOver:", gameOver); // DEBUG
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBoard(); 

            if (droppingPiece) {
                updateDroppingPiece();
                drawDroppingPiece(); 
            } else if (!gameOver) {
                // Logic for hover indicator (needs current mouse position, handled in mousemove)
            }
            
            if (gameOver && droppingPiece === null) { // Ensure piece has landed before highlighting
                // Attempt to find and highlight the winning line after the board is drawn
                // This is a simplified approach, a full solution would store the winning line
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (board[r][c] !== 0 && checkWin(r,c, board[r][c])) {
                           // This checkWin here is to re-verify, ideally highlight is called once
                           // highlightWinningPieces(r,c, board[r][c]); // Might highlight multiple if not careful
                           // For simplicity, the highlight is called when win is first detected.
                           // We just need to ensure the final board state is drawn.
                           break; // Found a win, no need to check further for highlighting
                        }
                    }
                     if (gameOver) break; 
                }
            }


            if (!gameOver) { 
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                 // Final draw to ensure winning highlight is visible if not already drawn
                drawBoard(); // Draw board with all pieces in place
                // The highlightWinningPieces was called when gameOver was set.
                // A better approach would be to store the winning line and draw it here.
                // For now, we rely on it being called once.
                console.log("Game Over. Loop stopped."); // DEBUG
            }
        }

        function startGame() {
            console.log("startGame called"); // DEBUG
            initializeBoard();
            currentPlayer = 1;
            gameOver = false;
            droppingPiece = null; 
            updateTurnDisplay();
            updateScoreDisplay(); // Update scores at start too
            messageArea.textContent = '';
            restartButton.style.display = 'none';
            
            if (animationFrameId) { 
                cancelAnimationFrame(animationFrameId);
                console.log("Cleared previous animation frame in startGame"); // DEBUG
            }
            // Start the game loop using requestAnimationFrame
            console.log("Requesting initial animation frame in startGame"); // DEBUG
            animationFrameId = requestAnimationFrame(gameLoop); 
        }

        canvas.addEventListener('click', (event) => {
            if (gameOver || droppingPiece) {
                console.log("Click ignored: gameOver or piece dropping"); // DEBUG
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const col = Math.floor(x / SQUARE_SIZE);

            if (col >= 0 && col < COLS) {
                console.log("Canvas clicked, column:", col); // DEBUG
                dropPiece(col);
            }
        });
        
        canvas.addEventListener('mousemove', (event) => {
            if (gameOver || droppingPiece) return; 
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const col = Math.floor(x / SQUARE_SIZE);

            // Redraw is handled by gameLoop, mousemove only needs to draw the hover indicator
            // To do this without full redraw, we'd need to save/restore part of the canvas
            // For simplicity, let's trigger a full draw but only if needed.
            // The gameLoop already redraws continuously. This hover might be better
            // drawn directly in the gameLoop based on stored mouse coordinates.
            // For now, let's keep it simple: the gameLoop will handle drawing.
            // We can add a specific hover drawing function called by gameLoop.
            // Let's remove the drawBoard() from here to avoid conflicts with animation.
            // The gameLoop will handle drawing the board and pieces.
            // The hover effect will be drawn on top by the gameLoop if we add it there.
            // For now, let's disable the hover redraw to ensure it's not the cause.
            
            // To implement hover properly without conflicting with animation:
            // 1. Store mouseCol in a global variable.
            // 2. In gameLoop, after drawBoard() and drawDroppingPiece(), draw the hover indicator at mouseCol.
            // This is a more advanced change. Let's first fix the dropping.
        });
        
        canvas.addEventListener('mouseleave', () => {
            if (gameOver || droppingPiece) return;
            // Similar to mousemove, the gameLoop should handle clearing any hover effects.
            // For now, do nothing here to avoid conflicts.
        });


        restartButton.addEventListener('click', startGame);
        
        window.cleanupGame = () => {
            console.log("Connect Four cleanup called.");
            gameOver = true; 
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        };

        // Initial setup
        startGame();

    </script>
</body>
</html>
