<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Memory Game Content</title>
<style>
    * { box-sizing: border-box; }
    body {
        margin: 0;
        font-family: Tahoma, sans-serif;
        background-color: #ece9d8; /* Match XP window background */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center; /* Center game content vertically */
        height: 100%;
        overflow: hidden;
        padding: 10px; /* Add some padding around the game area */
    }
    .game-container { /* Wrapper for centering */
        /* Styles for this can be added if needed, e.g., border */
    }
    .game-controls {
        padding-bottom: 10px; /* Space below controls */
        text-align: center;
        flex-shrink: 0;
    }
    .game-controls button {
        font-size: 13px;
        padding: 5px 12px;
        font-family: Tahoma, sans-serif;
        border: 1px outset #ccc;
        background-color: #d4d0c8;
    }
    .game-status {
        font-weight: bold;
        margin-top: 8px;
        min-height: 1.2em;
        font-size: 15px;
        color: #333;
    }
    #memory-grid {
        display: grid;
        /* Columns will be set by JS based on card count */
        gap: 8px; /* Gap between cards */
        perspective: 1000px;
        /* Max width to ensure it fits, can be adjusted */
        max-width: calc(4 * 80px + 3 * 8px); /* Example for 4 columns of 80px cards */
    }
    .memory-card {
        width: 80px; /* Standard card size, adjust if needed */
        height: 80px;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.5s;
        cursor: pointer;
        background-color: transparent;
    }
    .memory-card.flipped { transform: rotateY(180deg); }
    .memory-card.matched {
        cursor: default;
        opacity: 0.5; /* Visual cue for matched cards */
        transform: rotateY(180deg); /* Keep them flipped */
    }
    .card-face {
        position: absolute; width: 100%; height: 100%;
        backface-visibility: hidden;
        display: flex; align-items: center; justify-content: center;
        border: 1px solid #888; border-radius: 5px;
        font-size: 36px; /* Adjust symbol size */
    }
    .card-front { background-color: #4a90e2; color: white; /* XP blue-ish */ }
    .card-back { background-color: #f0f0f0; color: #333; transform: rotateY(180deg); }
</style>
</head>
<body>
    <div class="game-container">
        <div class="game-controls">
            <button id="memory-new-game">New Game</button>
            <div id="memory-status" class="game-status">Moves: 0</div>
        </div>
        <div id="memory-grid">
            <!-- Cards generated by JS -->
        </div>
    </div>

    <script>
        const grid = document.getElementById('memory-grid');
        const statusDiv = document.getElementById('memory-status');
        const newGameButton = document.getElementById('memory-new-game');

        const symbols = ['ðŸŽ', 'ðŸŒ', 'ðŸ‡', 'ðŸ‰', 'ðŸ“', 'ðŸ’', 'ðŸ', 'ðŸ¥']; // 8 pairs = 16 cards (4x4 grid)
        // For a 450x520 window, usable content height is ~496px.
        // 4 rows of 80px cards + 3 gaps of 8px = 320 + 24 = 344px. Plus controls. This should fit.
        // 4 cols of 80px cards + 3 gaps of 8px = 344px. Fits within 450px width.

        let cards = []; // This will store the DOM elements
        let cardValues = []; // This will store the shuffled symbol values
        let flippedCards = [];
        let matchedPairs = 0;
        let moves = 0;
        let lockBoard = false; // Prevent clicking during checks/animations
        let unflipTimeout = null; // Store timeout ID

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function createMemoryBoard() {
            console.log("[MemoryGame] createMemoryBoard called.");
            cleanupGame(); // Clear any pending unflip timeout

            grid.innerHTML = '';
            matchedPairs = 0;
            moves = 0;
            flippedCards = [];
            cards = []; // Clear DOM element references
            lockBoard = false;
            updateStatus();

            cardValues = shuffle([...symbols, ...symbols]);

            // Determine grid columns (e.g., aim for roughly square or fit width)
            const numCardsTotal = cardValues.length;
            let cols = 4; // Default for 16 cards
            if (numCardsTotal === 12) cols = 4; // 3x4 or 4x3
            else if (numCardsTotal === 20) cols = 5; // 4x5 or 5x4
            // Adjust grid styling
            const cardSize = 80;
            const gapSize = 8;
            grid.style.gridTemplateColumns = `repeat(${cols}, ${cardSize}px)`;
            grid.style.maxWidth = `${cols * cardSize + (cols - 1) * gapSize}px`;


            cardValues.forEach(value => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('memory-card');
                cardElement.dataset.value = value;
                cardElement.innerHTML = `
                    <div class="card-face card-front"></div>
                    <div class="card-face card-back">${value}</div>
                `;
                cardElement.addEventListener('click', handleCardFlip);
                grid.appendChild(cardElement);
                cards.push(cardElement); // Store reference
            });
            console.log("[MemoryGame] Board created.");
        }

        function handleCardFlip() {
            if (lockBoard || this.classList.contains('flipped') || this.classList.contains('matched') || flippedCards.length >= 2) {
                return;
            }

            this.classList.add('flipped');
            flippedCards.push(this);

            if (flippedCards.length === 2) {
                moves++;
                updateStatus();
                lockBoard = true;
                checkForMatch();
            }
        }

        function checkForMatch() {
            const [card1, card2] = flippedCards;
            const isMatch = card1.dataset.value === card2.dataset.value;

            if (isMatch) {
                disableCards();
            } else {
                unflipCards();
            }
        }

        function disableCards() {
            console.log("[MemoryGame] Match found!");
            flippedCards.forEach(card => {
                card.classList.add('matched');
                // No need to remove event listener if .matched class prevents interaction
            });
            matchedPairs++;
            resetBoardStateAfterCheck();
            checkWinCondition();
        }

        function unflipCards() {
            console.log("[MemoryGame] No match, un-flipping.");
            if (unflipTimeout) clearTimeout(unflipTimeout); // Clear existing timeout
            unflipTimeout = setTimeout(() => {
                flippedCards.forEach(card => card.classList.remove('flipped'));
                resetBoardStateAfterCheck();
                unflipTimeout = null; // Clear ID after execution
            }, 1000);
        }

        function resetBoardStateAfterCheck() {
            flippedCards = [];
            lockBoard = false;
        }

        function updateStatus() {
            statusDiv.textContent = `Moves: ${moves}`;
        }

        function checkWinCondition() {
             if (matchedPairs === symbols.length) {
                 console.log("[MemoryGame] Game Won!");
                 setTimeout(() => { // Allow last match visual to settle
                     statusDiv.textContent = `You won in ${moves} moves!`;
                 }, 500);
                 lockBoard = true; // Lock board after win
             }
        }

        // --- Cleanup Function ---
        function cleanupGame() {
            console.log(`[MemoryGame] cleanupGame called. Unflip Timeout ID: ${unflipTimeout}`);
            if (unflipTimeout) {
                clearTimeout(unflipTimeout);
                unflipTimeout = null;
                console.log("[MemoryGame] Unflip timeout cleared by cleanupGame.");
            }
            lockBoard = true; // Prevent further interaction
            // No global listeners or intervals to remove for this game typically,
            // unless more complex features were added.
        }

        // --- Event listener for messages from parent (for cleanup) ---
        window.addEventListener('message', (event) => {
            console.log(`[MemoryGame] Message received from parent. Data: "${event.data}", Origin: "${event.origin}"`);
            if (event.data === 'cleanup') {
                cleanupGame();
            }
        });

        // --- Initialization ---
        newGameButton.addEventListener('click', createMemoryBoard);
        createMemoryBoard(); // Start game on load
        window.focus();
    </script>
</body>
</html>
