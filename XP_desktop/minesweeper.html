<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Minesweeper Content</title>
<style>
    /* Added box-sizing */
    * { box-sizing: border-box; }
    /* Styles specific to Minesweeper */
    body {
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center; /* Center grid horizontally */
        background-color: #c0c0c0;
        height: 100%; /* Use 100% of iframe height */
        font-family: Tahoma, sans-serif;
        overflow: hidden; /* Prevent body scroll */
    }
    #minesweeper-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        padding: 5px 10px;
        background-color: #bbb;
        border-bottom: 1px solid #999;
        font-size: 14px;
        font-weight: bold;
        flex-shrink: 0; /* Don't shrink controls */
    }
    #mines-left, #mine-timer { background-color: #333; color: #ff0000; padding: 2px 5px; font-family: 'Courier New', monospace; border: 1px inset #777;}
    #minesweeper-grid {
        display: grid;
        gap: 1px;
        background-color: #888;
        border: 2px outset #f0f0f0;
        margin: 10px; /* Keep margin */
        /* Grid fills remaining space - no need for flex-grow on grid itself */
    }
    .mine-cell { width: 25px; height: 25px; background-color: #bdbdbd; border: 2px outset #e0e0e0; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold; cursor: pointer; }
    .mine-cell:active { border-style: inset; background-color: #aaa;}
    .mine-cell.revealed { background-color: #d0d0d0; border: 1px solid #999; }
    .mine-cell.flagged::before { content: 'ðŸš©'; color: red; }
    .mine-cell.mine-hit { background-color: red; }
    .mine-cell.mine-hit::before { content: 'ðŸ’£'; }
    .mine-cell.num1 { color: blue; } .mine-cell.num2 { color: green; } .mine-cell.num3 { color: red; } .mine-cell.num4 { color: darkblue; } .mine-cell.num5 { color: brown; } .mine-cell.num6 { color: cyan; } .mine-cell.num7 { color: black; } .mine-cell.num8 { color: grey; }
</style>
</head>
<body>
    <div id="minesweeper-controls">
        <div id="mines-left">Mines: 10</div>
        <button id="minesweeper-new-game" style="font-size: 20px; padding: 0 5px;">ðŸ™‚</button>
        <div id="mine-timer">Time: 0</div>
    </div>
    <div id="minesweeper-grid">
        <!-- Grid generated by JS -->
    </div>

    <script>
        // --- Minesweeper JS Logic (copied from previous - unchanged) ---
        const mineGridDiv = document.getElementById('minesweeper-grid'); const minesLeftDiv = document.getElementById('mines-left'); const mineTimerDiv = document.getElementById('mine-timer'); const mineNewGameButton = document.getElementById('minesweeper-new-game');
        let mineRows = 16, mineCols = 10, mineCount = 20; let mineBoard = [], minesRemaining, mineTime, mineTimerInterval = null, mineGameOver, minesFirstClick;
        function setupMineBoard() { mineBoard = []; mineGameOver = false; minesRemaining = mineCount; mineTime = 0; minesFirstClick = true; mineNewGameButton.textContent = 'ðŸ™‚'; if(mineTimerInterval) clearInterval(mineTimerInterval); mineTimerInterval = null; minesLeftDiv.textContent = `Mines: ${minesRemaining}`; mineTimerDiv.textContent = `Time: ${mineTime}`; mineGridDiv.innerHTML = ''; mineGridDiv.style.gridTemplateColumns = `repeat(${mineCols}, 25px)`; for (let r = 0; r < mineRows; r++) { mineBoard[r] = []; for (let c = 0; c < mineCols; c++) { mineBoard[r][c] = { isMine: false, isRevealed: false, isFlagged: false, adjacentMines: 0 }; const cell = document.createElement('div'); cell.classList.add('mine-cell'); cell.dataset.row = r; cell.dataset.col = c; cell.addEventListener('click', handleMineCellClick); cell.addEventListener('contextmenu', handleMineCellRightClick); mineGridDiv.appendChild(cell); } } renderMineBoard();}
        function placeMines(cr, cc) { let mtp = mineCount, attempts = 0; while (mtp > 0 && attempts < (mineRows*mineCols*2)) { const r = Math.floor(Math.random() * mineRows), c = Math.floor(Math.random() * mineCols); if (!mineBoard[r][c].isMine && (r !== cr || c !== cc) && (Math.abs(r - cr) > 1 || Math.abs(c - cc) > 1)) { mineBoard[r][c].isMine = true; mtp--; } attempts++;} if(mtp>0) console.warn("Could not place all mines"); for (let r=0; r<mineRows; r++) for (let c=0; c<mineCols; c++) { if (mineBoard[r]?.[c]?.isMine) continue; let count=0; for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr, nc=c+dc; if(nr>=0 && nr<mineRows && nc>=0 && nc<mineCols && mineBoard[nr][nc]?.isMine) count++;} if(mineBoard[r]?.[c]) mineBoard[r][c].adjacentMines=count;}} // Added safety
        function handleMineCellClick(event) { if (mineGameOver) return; const r = parseInt(event.currentTarget.dataset.row), c = parseInt(event.currentTarget.dataset.col); if(isNaN(r)||isNaN(c)) return; const cd = mineBoard[r]?.[c]; if (!cd || cd.isRevealed || cd.isFlagged) return; if (minesFirstClick) { placeMines(r, c); minesFirstClick = false; if(mineTimerInterval) clearInterval(mineTimerInterval); mineTimerInterval = setInterval(() => { mineTime++; mineTimerDiv.textContent = `Time: ${mineTime}`; }, 1000); } revealMineCell(r, c); checkMineWinCondition(); }
        function handleMineCellRightClick(event) { event.preventDefault(); if (mineGameOver || minesFirstClick) return; const r = parseInt(event.currentTarget.dataset.row), c = parseInt(event.currentTarget.dataset.col); if(isNaN(r)||isNaN(c)) return; const cd = mineBoard[r]?.[c]; if (!cd || cd.isRevealed) return; cd.isFlagged = !cd.isFlagged; if (cd.isFlagged) minesRemaining--; else minesRemaining++; minesLeftDiv.textContent = `Mines: ${minesRemaining}`; renderMineBoard(); }
        function revealMineCell(r, c) { if (r < 0 || r >= mineRows || c < 0 || c >= mineCols) return; const cd = mineBoard[r]?.[c]; if (!cd || cd.isRevealed || cd.isFlagged) return; cd.isRevealed = true; if (cd.isMine) { mineGameOver = true; mineNewGameButton.textContent = 'ðŸ˜µ'; if (mineTimerInterval) clearInterval(mineTimerInterval); mineTimerInterval = null; revealAllMines(); renderMineBoard(); return; } const cellDiv = mineGridDiv.querySelector(`.mine-cell[data-row='${r}'][data-col='${c}']`); if(cellDiv) updateCellDiv(cellDiv, cd); if (cd.adjacentMines === 0) { for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) { if (dr === 0 && dc === 0) continue; revealMineCell(r + dr, c + dc); } } }
        function updateCellDiv(cellDiv, cellData) { cellDiv.className = 'mine-cell'; if (cellData.isFlagged && !cellData.isRevealed) { cellDiv.classList.add('flagged'); cellDiv.textContent = ''; } else if (cellData.isRevealed) { cellDiv.classList.add('revealed'); cellDiv.textContent = ''; if (cellData.isMine) { cellDiv.classList.add('mine-hit'); } else if (cellData.adjacentMines > 0) { cellDiv.textContent = cellData.adjacentMines; cellDiv.classList.add(`num${cellData.adjacentMines}`); } } else { cellDiv.textContent = ''; } }
        function revealAllMines() { for (let r=0; r<mineRows; r++) for (let c=0; c<mineCols; c++) if (mineBoard[r]?.[c]?.isMine) mineBoard[r][c].isRevealed = true; }
        function renderMineBoard() { const cells = mineGridDiv.children; for (let i = 0; i < cells.length; i++) { const r = Math.floor(i / mineCols), c = i % mineCols; if (mineBoard[r]?.[c]) updateCellDiv(cells[i], mineBoard[r][c]);}}
        function checkMineWinCondition() { if (mineGameOver) return; let rc = 0, tsc = mineRows * mineCols - mineCount; for (let r=0; r<mineRows; r++) for (let c=0; c<mineCols; c++) if (mineBoard[r]?.[c]?.isRevealed && !mineBoard[r][c].isMine) rc++; if (rc === tsc) { mineGameOver = true; mineNewGameButton.textContent = 'ðŸ˜Ž'; if(mineTimerInterval) clearInterval(mineTimerInterval); mineTimerInterval = null; minesRemaining = 0; minesLeftDiv.textContent = `Mines: ${minesRemaining}`; for (let r=0; r<mineRows; r++) for (let c=0; c<mineCols; c++) if (mineBoard[r]?.[c]?.isMine && !mineBoard[r][c].isFlagged) mineBoard[r][c].isFlagged = true; renderMineBoard(); } }

        // --- Cleanup Function ---
        function cleanupGame() { console.log("Cleaning up Minesweeper"); if (mineTimerInterval) { clearInterval(mineTimerInterval); mineTimerInterval = null; } }

        // --- Initialization ---
        mineNewGameButton.addEventListener('click', setupMineBoard);
        setupMineBoard(); // Start game on load
    </script>
</body>
</html>