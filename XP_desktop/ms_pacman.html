<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ms. Pac-Man</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000000;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            color: #FFFF00; /* Yellow text */
        }
        #game-header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 448px; /* Maze width */
            margin-bottom: 10px;
            font-size: 14px;
            padding: 0 10px;
            box-sizing: border-box;
        }
        #gameCanvas {
            background-color: #000000;
            border: 2px solid #FF00FF; /* Ms. Pac-Man Pink border */
            box-shadow: 0 0 10px #FF00FF;
            display: block; /* Prevents extra space below canvas */
        }
        #controls-info {
            margin-top: 10px;
            font-size: 10px;
            text-align: center;
            color: #FFF;
        }
        #startMessage, #gameOverMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 20px; /* Adjusted for Press Start 2P */
            color: #FFFF00;
            background-color: rgba(0,0,0,0.85);
            padding: 25px;
            border-radius: 0px; /* Sharp edges for retro feel */
            border: 2px solid #FF00FF;
            z-index: 100;
            cursor: pointer;
            line-height: 1.5;
        }
        #gameOverMessage {
            display: none;
            cursor: default;
        }
        #gameOverMessage button {
            display: block;
            margin: 20px auto 0;
            padding: 10px 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            background-color: #FF00FF;
            color: #000;
            border: 2px solid #FFFF00;
            border-radius: 0px;
            cursor: pointer;
        }
        #gameOverMessage button:hover {
            background-color: #FFFF00;
            color: #000;
            border-color: #FF00FF;
        }
    </style>
</head>
<body>
    <div id="game-header">
        <div>SCORE: <span id="score">0</span></div>
        <div>LIVES: <span id="lives">0</span></div>
    </div>
    <canvas id="gameCanvas" tabindex="0"></canvas>
    <div id="controls-info">
        Use Arrow Keys to Move
    </div>

    <div id="startMessage">
        <p>MS. PAC-MAN</p>
        <p style="font-size: 12px;">Click or Press ENTER</p>
        <p style="font-size: 12px;">to Start</p>
    </div>
    <div id="gameOverMessage">
        <p>GAME OVER</p>
        <p style="font-size:14px;">Final Score: <span id="finalScore">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>

    <script>
        // Game setup and main logic will go here
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const startMessage = document.getElementById('startMessage');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        const TILE_SIZE = 16; // Size of each cell in the maze
        const ROWS = 31; // Standard Pac-Man maze height
        const COLS = 28; // Standard Pac-Man maze width

        canvas.width = COLS * TILE_SIZE;
        canvas.height = ROWS * TILE_SIZE;

        // Maze layout (0 = empty, 1 = wall, 2 = pellet, 3 = power pellet, 4 = ghost spawn, 5 = tunnel)
        // This is a simplified representation. A real Pac-Man maze is more complex.
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,3,1,1,1,2,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1,1,1,3,1],
            [1,2,1,1,1,2,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,2,1],
            [1,2,2,2,2,2,1,2,2,2,2,2,2,1,1,2,2,2,2,2,1,2,2,2,2,2,2,1],
            [1,1,1,1,1,2,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,2,1,1,1,1,1],
            [0,0,0,0,1,2,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,2,1,0,0,0,0], // Tunnel row start
            [1,1,1,1,1,2,1,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,2,1,1,1,1,1],
            [1,2,2,2,2,2,2,0,1,0,0,0,0,0,0,0,0,0,0,1,0,2,2,2,2,2,2,1],
            [1,1,1,1,1,2,1,0,1,0,1,1,1,4,4,1,1,1,0,1,0,1,2,1,1,1,1,1], // Ghost house area
            [1,0,0,0,1,2,1,0,1,0,1,4,4,4,4,4,4,1,0,1,0,1,2,1,0,0,0,1],
            [1,1,1,1,1,2,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,2,1,1,1,1,1],
            [5,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,5], // Tunnel row middle
            [1,1,1,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,0,1,0,1,2,1,1,1,1,1],
            [1,0,0,0,1,2,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,2,1,0,0,0,1],
            [1,1,1,1,1,2,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,2,1,1,1,1,1],
            [1,2,2,2,2,2,2,0,1,0,0,0,0,1,1,0,0,0,0,1,0,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,2,1,1,1,2,1],
            [1,3,2,2,1,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,2,2,3,2,1],
            [1,1,1,2,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,1,1,1],
            [1,2,2,2,2,2,1,2,2,2,2,2,2,1,1,2,2,2,2,2,1,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        let totalPellets = 0;

        // Game Objects
        let player;
        let ghosts = [];
        const GHOST_COLORS = ['#FF0000', '#FFB8FF', '#00FFFF', '#FFB852']; // Blinky, Pinky, Inky, Sue
        const GHOST_NAMES = ['blinky', 'pinky', 'inky', 'sue'];

        // Game State
        let score = 0;
        let lives = 3;
        let gameRunning = false;
        let frightenedMode = false;
        let frightenedTimer = 0;
        let animationFrameId;
        let mouthOpen = true;
        let mouthAnimationTimer = 0;
        const MOUTH_ANIMATION_SPEED = 8; // Higher is slower

        // Player properties
        const PLAYER_SPEED = TILE_SIZE / 8; // Move 1/8th of a tile per frame

        // Ghost properties
        const GHOST_SPEED = TILE_SIZE / 9;
        const FRIGHTENED_GHOST_SPEED = TILE_SIZE / 12;
        const FRIGHTENED_DURATION = 8 * 60; // 8 seconds at 60fps

        // --- Initialize ---
        function initGame() {
            score = 0;
            lives = 3;
            totalPellets = 0;
            maze.forEach(row => row.forEach(tile => { if (tile === 2 || tile === 3) totalPellets++; }));

            updateDisplay();
            player = new Player(13.5 * TILE_SIZE, 23 * TILE_SIZE); // Starting position
            
            ghosts = [];
            ghosts.push(new Ghost(13.5 * TILE_SIZE, 11 * TILE_SIZE, GHOST_COLORS[0], GHOST_NAMES[0])); // Blinky
            ghosts.push(new Ghost(11.5 * TILE_SIZE, 14 * TILE_SIZE, GHOST_COLORS[1], GHOST_NAMES[1])); // Pinky
            ghosts.push(new Ghost(13.5 * TILE_SIZE, 14 * TILE_SIZE, GHOST_COLORS[2], GHOST_NAMES[2])); // Inky
            ghosts.push(new Ghost(15.5 * TILE_SIZE, 14 * TILE_SIZE, GHOST_COLORS[3], GHOST_NAMES[3])); // Sue
            
            frightenedMode = false;
            frightenedTimer = 0;

            startMessage.style.display = 'none';
            gameOverMessage.style.display = 'none';
            gameRunning = true;
            canvas.focus();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        // --- Player Class ---
        function Player(x, y) {
            this.x = x;
            this.y = y;
            this.radius = TILE_SIZE * 0.4;
            this.speed = PLAYER_SPEED;
            this.dx = 0;
            this.dy = 0;
            this.nextDx = -1; // Start moving left
            this.nextDy = 0;
            this.mouthAngle = 0.2 * Math.PI; // For chomping animation

            this.update = function() {
                // Mouth animation
                mouthAnimationTimer++;
                if (mouthAnimationTimer % MOUTH_ANIMATION_SPEED === 0) {
                    mouthOpen = !mouthOpen;
                }
                this.mouthAngle = mouthOpen ? 0.2 * Math.PI : 0.01 * Math.PI;


                // Try to apply next direction
                if (this.nextDx !== 0 || this.nextDy !== 0) {
                    if (this.canMove(this.x + this.nextDx * this.speed, this.y + this.nextDy * this.speed)) {
                        this.dx = this.nextDx;
                        this.dy = this.nextDy;
                        this.nextDx = 0; // Reset queued direction
                        this.nextDy = 0;
                    }
                }
                
                // Move if current direction is valid
                if (this.canMove(this.x + this.dx * this.speed, this.y + this.dy * this.speed)) {
                    this.x += this.dx * this.speed;
                    this.y += this.dy * this.speed;
                } else { // Hit a wall, stop
                    this.dx = 0;
                    this.dy = 0;
                }


                // Tunneling
                if (this.x < -this.radius) this.x = canvas.width + this.radius;
                if (this.x > canvas.width + this.radius) this.x = -this.radius;

                // Eat pellets
                const gridX = Math.floor(this.x / TILE_SIZE);
                const gridY = Math.floor(this.y / TILE_SIZE);
                if (gridX >= 0 && gridX < COLS && gridY >= 0 && gridY < ROWS) {
                    if (maze[gridY][gridX] === 2) { // Pellet
                        maze[gridY][gridX] = 0; // Eat it
                        score += 10;
                        totalPellets--;
                        updateDisplay();
                    } else if (maze[gridY][gridX] === 3) { // Power pellet
                        maze[gridY][gridX] = 0;
                        score += 50;
                        totalPellets--;
                        activateFrightenedMode();
                        updateDisplay();
                    }
                }
            };

            this.canMove = function(targetX, targetY) {
                // Check all four corners of player's bounding box for simplicity
                const checkPoints = [
                    {x: targetX - this.radius * 0.8, y: targetY - this.radius * 0.8},
                    {x: targetX + this.radius * 0.8, y: targetY - this.radius * 0.8},
                    {x: targetX - this.radius * 0.8, y: targetY + this.radius * 0.8},
                    {x: targetX + this.radius * 0.8, y: targetY + this.radius * 0.8}
                ];

                for (let p of checkPoints) {
                    const gridX = Math.floor(p.x / TILE_SIZE);
                    const gridY = Math.floor(p.y / TILE_SIZE);
                    if (gridX < 0 || gridX >= COLS || gridY < 0 || gridY >= ROWS || maze[gridY][gridX] === 1) {
                        return false; // Hit a wall or out of bounds
                    }
                }
                return true;
            };

            this.draw = function() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, this.mouthAngle + this.getAngle(), -this.mouthAngle + this.getAngle());
                ctx.lineTo(this.x, this.y);
                ctx.fillStyle = '#FFFF00'; // Yellow
                ctx.fill();
                ctx.closePath();

                // Ms. Pac-Man's bow
                ctx.beginPath();
                ctx.arc(this.x + Math.cos(this.getAngle() + Math.PI/2) * this.radius * 0.7, 
                        this.y + Math.sin(this.getAngle() + Math.PI/2) * this.radius * 0.7, 
                        this.radius * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = '#FF0000'; // Red bow
                ctx.fill();
                ctx.closePath();
            };
            
            this.getAngle = function() { // Determine angle based on direction for mouth
                if (this.dx > 0) return 0; // Right
                if (this.dx < 0) return Math.PI; // Left
                if (this.dy > 0) return Math.PI / 2; // Down
                if (this.dy < 0) return -Math.PI / 2; // Up
                return 0; // Default (if not moving, keep last direction or default to right)
            }
        }
        
        // Ghost Class (Simplified AI)
        function Ghost(x, y, color, name) {
            this.x = x;
            this.y = y;
            this.radius = TILE_SIZE * 0.45;
            this.speed = GHOST_SPEED;
            this.dx = 0;
            this.dy = -1; // Start moving up
            this.color = color;
            this.name = name;
            this.state = 'scatter'; // scatter, chase, frightened, eaten
            this.frightenedTimer = 0;
            this.scatterTimer = 0;
            this.targetTile = {x:0, y:0}; // For pathfinding

            this.update = function() {
                if (this.state === 'frightened') {
                    this.speed = FRIGHTENED_GHOST_SPEED;
                    this.frightenedTimer--;
                    if (this.frightenedTimer <= 0) {
                        this.state = 'chase'; // Or scatter, depending on game logic
                        this.speed = GHOST_SPEED;
                    }
                } else if (this.state === 'eaten') {
                    // Pathfind back to ghost house center
                    this.targetTile = {x: 13.5, y: 14}; // Center of ghost house
                    if (Math.abs(this.x - this.targetTile.x * TILE_SIZE) < this.speed && Math.abs(this.y - this.targetTile.y * TILE_SIZE) < this.speed) {
                        this.state = 'chase'; // Respawn
                        this.x = 13.5 * TILE_SIZE;
                        this.y = 11 * TILE_SIZE; // Exit point
                    }
                } else { // Chase or Scatter
                    this.speed = GHOST_SPEED;
                    this.determineTargetTile();
                }

                this.move();
            };

            this.determineTargetTile = function() {
                // Basic AI: Blinky chases, Pinky ambushes, Inky is erratic, Sue is random/chases
                // This is highly simplified. True Pac-Man AI is complex.
                const playerGridX = Math.floor(player.x / TILE_SIZE);
                const playerGridY = Math.floor(player.y / TILE_SIZE);

                if (this.state === 'chase') {
                    if (this.name === 'blinky') this.targetTile = {x: playerGridX, y: playerGridY};
                    else if (this.name === 'pinky') { // Target 4 tiles ahead of Ms. Pac-Man
                        this.targetTile = {x: playerGridX + player.dx * 4, y: playerGridY + player.dy * 4};
                    } else if (this.name === 'inky') { // More complex, for now, also chase
                         this.targetTile = {x: playerGridX, y: playerGridY};
                    } else if (this.name === 'sue') { // Random or chase if close
                        if (distBetweenPoints(this.x, this.y, player.x, player.y) < TILE_SIZE * 8) {
                            this.targetTile = {x: playerGridX, y: playerGridY};
                        } else { // Scatter to corner
                             this.targetTile = {x: 1, y: ROWS - 2};
                        }
                    }
                } else if (this.state === 'scatter') { // Scatter to corners
                    if (this.name === 'blinky') this.targetTile = {x: COLS - 2, y: 1};
                    else if (this.name === 'pinky') this.targetTile = {x: 1, y: 1};
                    else if (this.name === 'inky') this.targetTile = {x: COLS -2, y: ROWS - 2};
                    else if (this.name === 'sue') this.targetTile = {x: 1, y: ROWS - 2};
                    
                    this.scatterTimer++;
                    if (this.scatterTimer > 7 * 60) { // Scatter for 7 seconds
                        this.state = 'chase';
                        this.scatterTimer = 0;
                    }
                }
                 if (this.state === 'frightened') { // Move randomly when frightened
                    if (Math.random() < 0.05) { // Occasionally change direction
                        const directions = [{dx:0, dy:-1},{dx:0, dy:1},{dx:-1, dy:0},{dx:1, dy:0}];
                        const newDir = directions[Math.floor(Math.random() * directions.length)];
                        if (this.canMove(this.x + newDir.dx * this.speed, this.y + newDir.dy * this.speed)) {
                            this.dx = newDir.dx; this.dy = newDir.dy;
                        }
                    }
                }

            };
            
            this.move = function() {
                if (this.state === 'eaten' || this.state === 'frightened') { // Simplified movement for these states
                    if (this.canMove(this.x + this.dx * this.speed, this.y + this.dy * this.speed)) {
                        this.x += this.dx * this.speed;
                        this.y += this.dy * this.speed;
                    } else { // Hit wall, pick a random valid direction
                        const directions = [{dx:0, dy:-1},{dx:0, dy:1},{dx:-1, dy:0},{dx:1, dy:0}];
                        let moved = false;
                        directions.sort(() => Math.random() - 0.5); // Shuffle
                        for(let dir of directions) {
                            if (this.canMove(this.x + dir.dx * this.speed, this.y + dir.dy * this.speed) && !(dir.dx === -this.dx && dir.dy === -this.dy)) { // Don't reverse immediately
                                this.dx = dir.dx; this.dy = dir.dy;
                                this.x += this.dx * this.speed; this.y += this.dy * this.speed;
                                moved = true;
                                break;
                            }
                        }
                    }
                } else { // Pathfinding for chase/scatter (very basic)
                    const currentGridX = Math.floor(this.x / TILE_SIZE);
                    const currentGridY = Math.floor(this.y / TILE_SIZE);
                    
                    // Only change direction at intersections (center of tile)
                    const atIntersection = (this.x % TILE_SIZE < this.speed && this.x % TILE_SIZE > -this.speed) && 
                                           (this.y % TILE_SIZE < this.speed && this.y % TILE_SIZE > -this.speed);

                    if (atIntersection) {
                        let bestDir = null;
                        let minDist = Infinity;
                        const directions = [{dx:0, dy:-1, name:"up"},{dx:0, dy:1, name:"down"},{dx:-1, dy:0, name:"left"},{dx:1, dy:0, name:"right"}];
                        
                        for (let dir of directions) {
                            // Don't allow reversing direction unless at a dead end
                            if (dir.dx === -this.dx && dir.dy === -this.dy) continue;

                            const nextX = this.x + dir.dx * TILE_SIZE; // Check one tile ahead
                            const nextY = this.y + dir.dy * TILE_SIZE;
                            if (this.canMove(nextX, nextY)) {
                                const dist = distBetweenPoints(nextX, nextY, this.targetTile.x * TILE_SIZE, this.targetTile.y * TILE_SIZE);
                                if (dist < minDist) {
                                    minDist = dist;
                                    bestDir = dir;
                                }
                            }
                        }
                        if (bestDir) {
                            this.dx = bestDir.dx;
                            this.dy = bestDir.dy;
                        } else { // Stuck, try to reverse
                             if (this.canMove(this.x - this.dx * TILE_SIZE, this.y - this.dy * TILE_SIZE)) {
                                this.dx = -this.dx;
                                this.dy = -this.dy;
                            }
                        }
                    }
                }
                // Actual movement based on chosen dx, dy
                if (this.canMove(this.x + this.dx * this.speed, this.y + this.dy * this.speed)) {
                    this.x += this.dx * this.speed;
                    this.y += this.dy * this.speed;
                } else { // If somehow still stuck, reset dx/dy to allow new decision
                    this.dx = 0; this.dy = 0;
                }


                // Tunneling
                if (this.x < -this.radius) this.x = canvas.width + this.radius;
                if (this.x > canvas.width + this.radius) this.x = -this.radius;
            };


            this.canMove = function(targetX, targetY) {
                const checkPoints = [ // Check center and edges of ghost
                    {x: targetX, y: targetY},
                    {x: targetX - this.radius*0.9, y: targetY}, {x: targetX + this.radius*0.9, y: targetY},
                    {x: targetX, y: targetY - this.radius*0.9}, {x: targetX, y: targetY + this.radius*0.9}
                ];
                for (let p of checkPoints) {
                    const gridX = Math.floor(p.x / TILE_SIZE);
                    const gridY = Math.floor(p.y / TILE_SIZE);
                     if (gridX < 0 || gridX >= COLS || gridY < 0 || gridY >= ROWS || maze[gridY][gridX] === 1) {
                        return false; 
                    }
                }
                return true;
            };

            this.draw = function() {
                let drawColor = this.color;
                if (this.state === 'frightened') {
                    drawColor = frightenedTimer % 40 < 20 ? '#0000FF' : '#FFFFFF'; // Blue/White flashing
                } else if (this.state === 'eaten') {
                    // Draw only eyes
                    ctx.fillStyle = '#FFF';
                    ctx.beginPath();
                    ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.1, this.radius * 0.2, 0, Math.PI * 2);
                    ctx.arc(this.x + this.radius * 0.3, this.y - this.radius * 0.1, this.radius * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    return; // Skip main body drawing
                }

                ctx.fillStyle = drawColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, Math.PI, 0); // Top semi-circle
                ctx.lineTo(this.x + this.radius, this.y + this.radius * 0.8);
                // Jagged bottom
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(this.x + this.radius * (0.8 - i * 0.4), this.y + this.radius * (i % 2 === 0 ? 0.8 : 0.5));
                }
                ctx.lineTo(this.x - this.radius, this.y + this.radius * 0.8);
                ctx.closePath();
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.1, this.radius * 0.25, 0, Math.PI * 2);
                ctx.arc(this.x + this.radius * 0.3, this.y - this.radius * 0.1, this.radius * 0.25, 0, Math.PI * 2);
                ctx.fill();

                // Pupils (move based on ghost direction)
                ctx.fillStyle = '#000';
                let pupilOffsetX = this.dx * this.radius * 0.1;
                let pupilOffsetY = this.dy * this.radius * 0.1;
                ctx.beginPath();
                ctx.arc(this.x - this.radius * 0.3 + pupilOffsetX, this.y - this.radius * 0.1 + pupilOffsetY, this.radius * 0.1, 0, Math.PI * 2);
                ctx.arc(this.x + this.radius * 0.3 + pupilOffsetX, this.y - this.radius * 0.1 + pupilOffsetY, this.radius * 0.1, 0, Math.PI * 2);
                ctx.fill();
            };
        }
        
        function activateFrightenedMode() {
            frightenedMode = true;
            frightenedTimer = FRIGHTENED_DURATION;
            ghosts.forEach(ghost => {
                if (ghost.state !== 'eaten') {
                    ghost.state = 'frightened';
                    ghost.frightenedTimer = FRIGHTENED_DURATION;
                    // Reverse direction
                    ghost.dx *= -1;
                    ghost.dy *= -1;
                }
            });
        }

        // --- Game Loop & Drawing ---
        function update() {
            player.update();
            ghosts.forEach(ghost => ghost.update());
            checkCollisions();

            if (totalPellets === 0) {
                levelComplete();
            }
            
            if (frightenedMode) {
                frightenedTimer--;
                if (frightenedTimer <= 0) {
                    frightenedMode = false;
                    ghosts.forEach(ghost => { if(ghost.state === 'frightened') ghost.state = 'chase'; });
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            drawPellets();
            player.draw();
            ghosts.forEach(ghost => ghost.draw());
        }

        function gameLoop() {
            if (!gameRunning) {
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
                 return;
            }
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function drawMaze() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (maze[r][c] === 1) { // Wall
                        ctx.fillStyle = '#0000FF'; // Blue walls
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }

        function drawPellets() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (maze[r][c] === 2) { // Pellet
                        ctx.beginPath();
                        ctx.arc(c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 8, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFB8AE'; // Pellet color (light pink/peach)
                        ctx.fill();
                        ctx.closePath();
                    } else if (maze[r][c] === 3) { // Power Pellet
                        ctx.beginPath();
                        ctx.arc(c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 4, 0, Math.PI * 2);
                        // Blinking effect for power pellet
                        ctx.fillStyle = (Math.floor(Date.now() / 200) % 2 === 0) ? '#FFB8FF' : '#FFA500';
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }
        
        function checkCollisions() {
            // Player with Ghosts
            ghosts.forEach(ghost => {
                if (distBetweenPoints(player.x, player.y, ghost.x, ghost.y) < player.radius + ghost.radius) {
                    if (ghost.state === 'frightened') {
                        score += 200; // Score for eating ghost
                        ghost.state = 'eaten';
                        ghost.x = 13.5 * TILE_SIZE; // Send to ghost house center (approx)
                        ghost.y = 14 * TILE_SIZE;
                        // Ghost will pathfind back from here
                    } else if (ghost.state !== 'eaten') {
                        lives--;
                        updateDisplay();
                        if (lives <= 0) {
                            gameOver();
                        } else {
                            resetPlayerAndGhosts(); // Reset positions after losing a life
                        }
                    }
                }
            });
        }
        
        function resetPlayerAndGhosts() {
            player.x = 13.5 * TILE_SIZE;
            player.y = 23 * TILE_SIZE;
            player.dx = -1; player.dy = 0; // Start moving left

            ghosts[0].x = 13.5 * TILE_SIZE; ghosts[0].y = 11 * TILE_SIZE; ghosts[0].state = 'scatter'; // Blinky
            ghosts[1].x = 11.5 * TILE_SIZE; ghosts[1].y = 14 * TILE_SIZE; ghosts[1].state = 'scatter'; // Pinky
            ghosts[2].x = 13.5 * TILE_SIZE; ghosts[2].y = 14 * TILE_SIZE; ghosts[2].state = 'scatter'; // Inky
            ghosts[3].x = 15.5 * TILE_SIZE; ghosts[3].y = 14 * TILE_SIZE; ghosts[3].state = 'scatter'; // Sue
            ghosts.forEach(g => { g.frightenedTimer = 0; g.scatterTimer = 0; g.dx = 0; g.dy = -1;});
        }

        function levelComplete() {
            // For simplicity, just restart the level with pellets refilled
            // A more advanced version would load a new maze or increase difficulty
            console.log("Level Complete!");
            // Reset pellets
            totalPellets = 0;
             for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    // This is a simplified maze copy, ideally, store original maze
                    if (originalMazeLayout[r][c] === 2 || originalMazeLayout[r][c] === 3) {
                        maze[r][c] = originalMazeLayout[r][c];
                        totalPellets++;
                    }
                }
            }
            resetPlayerAndGhosts();
            // Add a small delay or message before continuing
        }
        // Store original maze to reset pellets (simple way)
        const originalMazeLayout = JSON.parse(JSON.stringify(maze));


        function distBetweenPoints(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function updateDisplay() {
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
        }

        function gameOver() {
            gameRunning = false;
            finalScoreDisplay.textContent = score;
            gameOverMessage.style.display = 'block';
            startMessage.style.display = 'none';
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            if (!gameRunning && (e.key === 'Enter' || e.code === 'Space') && startMessage.style.display !== 'none') {
                initGame();
            }
            if (!gameRunning) return;

            switch(e.key) {
                case 'ArrowUp': case 'w': player.nextDx = 0; player.nextDy = -1; e.preventDefault(); break;
                case 'ArrowDown': case 's': player.nextDx = 0; player.nextDy = 1; e.preventDefault(); break;
                case 'ArrowLeft': case 'a': player.nextDx = -1; player.nextDy = 0; e.preventDefault(); break;
                case 'ArrowRight': case 'd': player.nextDx = 1; player.nextDy = 0; e.preventDefault(); break;
            }
        });
        
        startMessage.addEventListener('click', () => { 
            if (!gameRunning && startMessage.style.display !== 'none') {
                initGame();
            }
        });

        restartButton.addEventListener('click', () => {
            gameOverMessage.style.display = 'none';
            startMessage.style.display = 'block'; 
        });

        // --- Initial Call ---
        window.addEventListener('resize', () => { /* Canvas size is fixed, but keep for consistency */ });
        setupCanvas(); 
        updateDisplay(); // Show initial lives

        // --- Cleanup for parent iframe ---
        window.cleanupGame = () => {
            console.log("Ms. Pac-Man cleanup called.");
            gameRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        };
    </script>
</body>
</html>
