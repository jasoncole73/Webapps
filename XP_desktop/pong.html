<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Pong Game</title>
<style>
    /* Styles specific to Pong */
     * { box-sizing: border-box; }
     body {
        margin: 0;
        font-family: Tahoma, sans-serif;
        background-color: #ece9d8; /* Match XP window background for consistency */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start; /* Align content to top */
        height: 100%; /* Full iframe height */
        overflow: hidden; /* Prevent scrollbars on body */
        padding-top: 5px;
    }
     .game-controls {
        padding: 5px;
        text-align: center;
        width: 100%;
        flex-shrink: 0;
    }
     .game-status {
        font-weight: bold;
        margin: 5px 0;
        min-height: 1.2em;
        font-size: 14px;
        color: #333; /* Color for status text */
    }
     #pong-canvas {
        border: 2px solid #333;
        background-color: #000; /* Black background */
        margin-top: 5px;
        display: block; /* Remove extra space under canvas */
        cursor: none; /* Hide cursor over canvas during play */
    }
</style>
</head>
<body>
    <div class="game-controls">
        <div id="pong-status" class="game-status">Player: 0 | AI: 0</div>
        <!-- You can add a "New Game" button here if desired for manual restarts -->
        <!-- <button id="pong-new-game-button">New Game</button> -->
    </div>
    <canvas id="pong-canvas" width="600" height="400" tabindex="0"></canvas>
    <!-- tabindex="0" makes the canvas focusable. -->

    <script>
        const canvas = document.getElementById('pong-canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('pong-status');
        // const newGameButton = document.getElementById('pong-new-game-button');

        const paddleHeight = 80;
        const paddleWidth = 10;
        const ballRadius = 7; // Slightly smaller ball

        let playerY;
        let aiY;
        let ballX, ballY;
        let ballSpeedX, ballSpeedY;
        let playerScore, aiScore;
        let gameLoopInterval = null;
        let gameIsActive = false; // To control game loop and input

        // Store mouse move handler for adding/removing correctly
        const pongMouseMoveHandler = (event) => {
            if (!gameIsActive) return;
            const rect = canvas.getBoundingClientRect(); // Get canvas position relative to viewport
            let mouseY = event.clientY - rect.top;    // Calculate mouse Y relative to canvas top
            playerY = mouseY - paddleHeight / 2;      // Center paddle on mouse

            // Keep player paddle within canvas bounds
            if (playerY < 0) {
                playerY = 0;
            } else if (playerY > canvas.height - paddleHeight) {
                playerY = canvas.height - paddleHeight;
            }
        };

        function resetBall(winner) { // winner can be 'player' or 'ai'
            ballX = canvas.width / 2;
            ballY = canvas.height / 2;
            let direction = 1;
            if (winner === 'player') { // If player scored, AI serves (ball goes towards player)
                direction = -1;
            } else if (winner === 'ai') { // If AI scored, player serves (ball goes towards AI)
                direction = 1;
            } else { // Initial serve or if no winner specified (e.g. new game)
                direction = (Math.random() < 0.5) ? 1 : -1;
            }

            ballSpeedX = 5 * direction; // Speed and direction
            ballSpeedY = (Math.random() < 0.5 ? 2.5 : -2.5) + (Math.random() * 2 - 1); // Add some Y variation
        }

        function setupPongGame() {
            console.log("[Pong] setupPongGame called.");
            cleanupGame(); // Clear any existing game state first

            playerScore = 0;
            aiScore = 0;
            playerY = (canvas.height - paddleHeight) / 2;
            aiY = (canvas.height - paddleHeight) / 2;
            updatePongStatus();
            resetBall(); // Initial ball position and speed

            // Add event listener for mouse movement to control the player's paddle
            // Adding to 'canvas' ensures it only tracks when mouse is over the game area
            // and canvas has focus.
            canvas.addEventListener('mousemove', pongMouseMoveHandler);
            console.log("[Pong] Mousemove listener added to canvas.");

            // Attempt to focus the canvas so it can receive events (if applicable, mouse doesn't strictly need it like keys)
            // The parent iframe also attempts to focus.
            canvas.focus();

            gameIsActive = true; // Start the game logic
            gameLoopInterval = setInterval(gameLoop, 1000 / 60); // ~60 FPS
            console.log("[Pong] Game setup complete. Interval ID:", gameLoopInterval);
            drawGame(); // Initial draw
        }

        function drawRect(x, y, w, h, color) { ctx.fillStyle = color; ctx.fillRect(x, y, w, h); }
        function drawCircle(x, y, r, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2, false); ctx.fill(); }
        function drawNet() { for (let i = 10; i < canvas.height - 10; i += 30) drawRect(canvas.width/2 - 1, i, 2, 20, 'grey'); } // Dashed net

        function movePaddles() {
            if (!gameIsActive) return;
            // AI Paddle Movement (simple predictive)
            const aiCenter = aiY + paddleHeight / 2;
            const aiSpeed = 4; // AI paddle speed
            if (ballSpeedX > 0) { // Only move AI if ball is coming towards it
                if (aiCenter < ballY - paddleHeight * 0.35) { // AI tries to center on ball Y
                    aiY += aiSpeed;
                } else if (aiCenter > ballY + paddleHeight * 0.35) {
                    aiY -= aiSpeed;
                }
            }
            // Keep AI paddle within bounds
            if (aiY < 0) aiY = 0;
            if (aiY > canvas.height - paddleHeight) aiY = canvas.height - paddleHeight;
        }

        function moveBall() {
            if (!gameIsActive) return;
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            // Wall collision (top/bottom)
            if (ballY - ballRadius < 0 && ballSpeedY < 0) { // Hit top wall
                ballSpeedY = -ballSpeedY;
                ballY = ballRadius; // Prevent sticking
            } else if (ballY + ballRadius > canvas.height && ballSpeedY > 0) { // Hit bottom wall
                ballSpeedY = -ballSpeedY;
                ballY = canvas.height - ballRadius; // Prevent sticking
            }

            // Player paddle collision (left paddle)
            if (ballX - ballRadius < paddleWidth &&          // Ball's left edge is at or behind player paddle's right edge
                ballX - ballRadius > 0 &&                    // Ball's left edge hasn't passed through the paddle completely
                ballY + ballRadius > playerY &&              // Ball's bottom is below player paddle's top
                ballY - ballRadius < playerY + paddleHeight && // Ball's top is above player paddle's bottom
                ballSpeedX < 0) {                            // Ball is moving towards player
                    ballSpeedX = -ballSpeedX * 1.05; // Reverse direction and slightly increase speed
                    let deltaY = ballY - (playerY + paddleHeight / 2);
                    ballSpeedY = deltaY * 0.30; // Adjust angle based on hit position
                    ballX = paddleWidth + ballRadius; // Prevent sticking
            }

            // AI paddle collision (right paddle)
            if (ballX + ballRadius > canvas.width - paddleWidth && // Ball's right edge is at or past AI paddle's left edge
                ballX + ballRadius < canvas.width &&                 // Ball's right edge hasn't passed through AI paddle
                ballY + ballRadius > aiY &&                      // Ball's bottom is below AI paddle's top
                ballY - ballRadius < aiY + paddleHeight &&         // Ball's top is above AI paddle's bottom
                ballSpeedX > 0) {                                // Ball is moving towards AI
                    ballSpeedX = -ballSpeedX * 1.05;
                    let deltaY = ballY - (aiY + paddleHeight / 2);
                    ballSpeedY = deltaY * 0.30;
                    ballX = canvas.width - paddleWidth - ballRadius; // Prevent sticking
            }

            // Scoring
            if (ballX + ballRadius < 0) { // Ball passed left edge (AI scores)
                aiScore++;
                updatePongStatus();
                resetBall('ai'); // AI serves next
            } else if (ballX - ballRadius > canvas.width) { // Ball passed right edge (Player scores)
                playerScore++;
                updatePongStatus();
                resetBall('player'); // Player serves next
            }
        }

        function updatePongStatus() { statusDiv.textContent = `Player: ${playerScore} | AI: ${aiScore}`; }

        function drawGame() {
            drawRect(0, 0, canvas.width, canvas.height, 'black'); // Clear screen
            drawNet();
            drawRect(0, playerY, paddleWidth, paddleHeight, 'white'); // Player paddle
            drawRect(canvas.width - paddleWidth, aiY, paddleWidth, paddleHeight, 'white'); // AI paddle
            drawCircle(ballX, ballY, ballRadius, 'white'); // Ball
        }

        function gameLoop() {
            if (!gameIsActive) {
                cleanupGame(); // Ensure cleanup if loop runs when inactive
                return;
            }
            movePaddles();
            moveBall();
            drawGame();
        }

        // --- Cleanup Function ---
        function cleanupGame() {
            console.log(`[Pong] cleanupGame called. Current interval ID: ${gameLoopInterval}. Game active: ${gameIsActive}`);
            gameIsActive = false;
            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
                gameLoopInterval = null;
                console.log("[Pong] Interval cleared by cleanupGame.");
            }
            // Remove the listener specifically from the canvas
            canvas.removeEventListener('mousemove', pongMouseMoveHandler);
            console.log("[Pong] Mousemove listener removed by cleanupGame.");
        }

        // --- Event listener for messages from parent (for cleanup) ---
        window.addEventListener('message', (event) => {
            console.log(`[Pong] Message received from parent. Data: "${event.data}", Origin: "${event.origin}"`);
            if (event.data === 'cleanup') {
                cleanupGame();
            }
        });

        // --- Initialization ---
        // if (newGameButton) newGameButton.addEventListener('click', setupPongGame); // If you add a button
        setupPongGame(); // Start game on load

        // The parent xp_desktop.html also attempts to focus the iframe.
        // Focusing the window/canvas helps ensure it's receptive to events.
        window.focus();
        canvas.focus(); // Explicitly focus canvas

    </script>
</body>
</html>
